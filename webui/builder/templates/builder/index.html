<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Dossier Builder</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        fieldset { margin-bottom: 20px; padding: 15px; }
        label { display: block; margin-top: 8px; }
        input[type="text"], select, textarea { width: 100%; padding: 4px; box-sizing: border-box; }
        button { margin-top: 12px; padding: 6px 12px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 4px; font-size: 13px; }
        th { background: #f5f5f5; text-align: left; }
        .json-table { max-height: 280px; overflow: auto; display: block; }
        .path-cell { width: 40%; font-family: monospace; }
        .value-cell input { width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <h1>Dossier Builder</h1>

    <fieldset>
        <legend><strong>Crear JSON vacío desde plantilla</strong></legend>
        <form id="json_creator_form" method="post" action="{% url 'create_json' %}">
            {% csrf_token %}

            <label>JSON base en carpeta Plantillas:</label>
            <select name="json_template" id="json_template_select" required>
                {% if json_base_templates %}
                    {% for j in json_base_templates %}
                        <option value="{{ j.value }}">{{ j.name }}</option>
                    {% endfor %}
                {% else %}
                    <option value="">(No hay JSON base en Plantillas)</option>
                {% endif %}
            </select>

            <label>Nombre del JSON de salida:</label>
            <input type="text" name="json_out_name" placeholder="Ej: ITAU_2020_blank.json">

            <div class="json-table">
                <table>
                    <thead>
                        <tr>
                            <th>Ruta (path)</th>
                            <th>Valor</th>
                        </tr>
                    </thead>
                    <tbody id="json_creator_fields">
                        <!-- filas generadas por JS -->
                    </tbody>
                </table>
            </div>

            <!-- aquí se guarda el JSON reconstruido antes de enviar -->
            <input type="hidden" name="json_text" id="json_creator_text_hidden">

            <button type="submit">Generar JSON vacío</button>
        </form>
    </fieldset>

    <!-- WORD -->
    <fieldset>
        <legend><strong>Generar Word</strong></legend>
        <form id="word_form" method="post" enctype="multipart/form-data" action="{% url 'run_word' %}">
            {% csrf_token %}

            <label>Plantilla Word (base_docx):</label>
            <select name="word_base">
                {% for tpl in word_templates %}
                    <option value="{{ tpl.value }}"
                        {% if tpl.value == word_base_default %}selected{% endif %}>
                        {{ tpl.name }}
                    </option>
                {% endfor %}
            </select>

            <label>Mapping (mapping_json):</label>
            <select name="word_mapping">
                {% for m in mapping_templates %}
                    <option value="{{ m.value }}"
                        {% if m.value == word_mapping_default %}selected{% endif %}>
                        {{ m.name }}
                    </option>
                {% endfor %}
            </select>

            <label>Nombre archivo Word:</label>
            <input type="text" name="word_out_name" value="{{ word_out_name_default }}">

            <label>JSON de datos (selecciona archivo y edita campos):</label>
            <input type="file" id="word_json_file" accept=".json">

            <!-- aquí se pintan los campos del JSON -->
            <div class="json-table">
                <table>
                    <thead>
                        <tr>
                            <th>Ruta (path)</th>
                            <th>Valor</th>
                        </tr>
                    </thead>
                    <tbody id="word_json_fields">
                        <!-- filas generadas por JS -->
                    </tbody>
                </table>
            </div>

            <!-- aquí se guardará el JSON reconstruido antes de enviar -->
            <input type="hidden" name="word_json_text" id="word_json_text_hidden">

            <button type="submit">Generar Word</button>
        </form>
    </fieldset>

    <!-- EXCEL -->
    <fieldset>
        <legend><strong>Generar Excel</strong></legend>
        <form id="excel_form" method="post" enctype="multipart/form-data" action="{% url 'run_excel' %}">
            {% csrf_token %}

            <label>Plantilla Excel (base_excel):</label>
            <select name="excel_base">
                {% for tpl in excel_templates %}
                    <option value="{{ tpl.value }}"
                        {% if tpl.value == excel_base_default %}selected{% endif %}>
                        {{ tpl.name }}
                    </option>
                {% endfor %}
            </select>

            <label>Mapping (mapping_json):</label>
            <select name="excel_mapping">
                {% for m in mapping_templates %}
                    <option value="{{ m.value }}"
                        {% if m.value == excel_mapping_default %}selected{% endif %}>
                        {{ m.name }}
                    </option>
                {% endfor %}
            </select>

            <label>Nombre archivo Excel:</label>
            <input type="text" name="excel_out_name" value="{{ excel_out_name_default }}">

            <label>JSON de datos (selecciona archivo y edita campos):</label>
            <input type="file" id="excel_json_file" accept=".json">

            <div class="json-table">
                <table>
                    <thead>
                        <tr>
                            <th>Ruta (path)</th>
                            <th>Valor</th>
                        </tr>
                    </thead>
                    <tbody id="excel_json_fields">
                        <!-- filas generadas por JS -->
                    </tbody>
                </table>
            </div>

            <input type="hidden" name="excel_json_text" id="excel_json_text_hidden">

            <button type="submit">Generar Excel</button>
        </form>
    </fieldset>

    <fieldset>
        <legend><strong>Subir nueva plantilla</strong></legend>
        <form method="post" enctype="multipart/form-data" action="{% url 'upload_template' %}">
            {% csrf_token %}

            <label>Archivo de plantilla (.docx o .xlsx):</label>
            <input type="file" name="template_file" accept=".docx,.xlsx" required>

            <label>Nombre opcional (sin ruta):</label>
            <input type="text" name="template_name" placeholder="Ej: 1839 - Informe parcial v2.docx">

            <button type="submit">Subir plantilla a carpeta Plantillas</button>
        </form>
    </fieldset>

    <script>
        // Aplana un objeto JSON en pares {path, value} usando '||' (mismo criterio que tus mappings)
        function flattenJson(obj, prefix = "") {
            const result = [];
            for (const [key, val] of Object.entries(obj)) {
                const path = prefix ? prefix + "||" + key : key;
                if (val !== null && typeof val === "object" && !Array.isArray(val)) {
                    result.push(...flattenJson(val, path));
                } else {
                    result.push({ path, value: val == null ? "" : String(val) });
                }
            }
            return result;
        }

        // Reconstruye un objeto desde pares {path, value}
        function unflattenJson(pairs) {
            const root = {};
            for (const { path, value } of pairs) {
                const keys = path.split("||");
                let cur = root;
                for (let i = 0; i < keys.length; i++) {
                    const k = keys[i];
                    if (i === keys.length - 1) {
                        // inferir tipo básico
                        let v = value;
                        const trimmed = (v ?? "").trim();
                        if (trimmed === "true") v = true;
                        else if (trimmed === "false") v = false;
                        else if (trimmed === "null") v = null;
                        else if (trimmed !== "" && !isNaN(trimmed)) v = Number(trimmed);
                        cur[k] = v;
                    } else {
                        if (typeof cur[k] !== "object" || cur[k] === null || Array.isArray(cur[k])) {
                            cur[k] = {};
                        }
                        cur = cur[k];
                    }
                }
            }
            return root;
        }

        function setupJsonEditor(prefix) {
            const fileInput = document.getElementById(prefix + "_json_file");
            const tbody = document.getElementById(prefix + "_json_fields");
            const hidden = document.getElementById(prefix + "_json_text_hidden");
            const form = document.getElementById(prefix + "_form");

            if (!fileInput || !tbody || !hidden || !form) return;

            // Cuando se selecciona un archivo JSON
            fileInput.addEventListener("change", function () {
                const file = this.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const raw = e.target.result;
                        const parsed = JSON.parse(raw);

                        if (parsed === null || typeof parsed !== "object" || Array.isArray(parsed)) {
                            alert("El JSON raíz debe ser un objeto (no un arreglo ni un valor simple).");
                            return;
                        }

                        const pairs = flattenJson(parsed);

                        tbody.innerHTML = "";
                        for (const pair of pairs) {
                            const tr = document.createElement("tr");

                            const tdPath = document.createElement("td");
                            tdPath.className = "path-cell";
                            tdPath.textContent = pair.path;

                            const tdValue = document.createElement("td");
                            tdValue.className = "value-cell";
                            const input = document.createElement("input");
                            input.type = "text";
                            input.value = pair.value;
                            input.dataset.path = pair.path;
                            tdValue.appendChild(input);

                            tr.appendChild(tdPath);
                            tr.appendChild(tdValue);
                            tbody.appendChild(tr);
                        }

                        hidden.value = JSON.stringify(parsed, null, 2);
                    } catch (err) {
                        console.error(err);
                        alert("No se pudo leer o parsear el JSON: " + err);
                    }
                };
                reader.readAsText(file, "utf-8");
            });

            // Antes de enviar el formulario, reconstruimos el JSON desde las filas
            form.addEventListener("submit", function (e) {
                const inputs = tbody.querySelectorAll("input[data-path]");
                if (!inputs.length) {
                    alert("No hay campos JSON cargados para " + prefix.toUpperCase() + ".");
                    e.preventDefault();
                    return;
                }

                const pairs = [];
                inputs.forEach((input) => {
                    pairs.push({ path: input.dataset.path, value: input.value });
                });

                try {
                    const obj = unflattenJson(pairs);
                    hidden.value = JSON.stringify(obj, null, 2);
                } catch (err) {
                    console.error(err);
                    alert("Error reconstruyendo el JSON: " + err);
                    e.preventDefault();
                }
            });
        }

        function setupJsonCreator() {
            const select = document.getElementById("json_template_select");
            const tbody = document.getElementById("json_creator_fields");
            const hidden = document.getElementById("json_creator_text_hidden");
            const form = document.getElementById("json_creator_form");

            if (!select || !tbody || !hidden || !form) return;

            // Cuando cambias de plantilla base
            select.addEventListener("change", function () {
                const value = select.value;
                if (!value) {
                    tbody.innerHTML = "";
                    hidden.value = "";
                    return;
                }

                fetch("{% url 'get_json_template' %}?json_template=" + encodeURIComponent(value))
                    .then((resp) => {
                        if (!resp.ok) {
                            throw new Error("Error al cargar JSON base");
                        }
                        return resp.json();
                    })
                    .then((data) => {
                        const pairs = flattenJson(data);
                        tbody.innerHTML = "";

                        for (const pair of pairs) {
                            const tr = document.createElement("tr");

                            const tdPath = document.createElement("td");
                            tdPath.className = "path-cell";
                            tdPath.textContent = pair.path;

                            const tdValue = document.createElement("td");
                            tdValue.className = "value-cell";
                            const input = document.createElement("input");
                            input.type = "text";
                            input.value = pair.value; // viene "" desde _blank_leaves
                            input.dataset.path = pair.path;
                            tdValue.appendChild(input);

                            tr.appendChild(tdPath);
                            tr.appendChild(tdValue);
                            tbody.appendChild(tr);
                        }

                        // dejamos hidden vacío; se llenará al enviar
                        hidden.value = "";
                    })
                    .catch((err) => {
                        console.error(err);
                        alert("No se pudo cargar el JSON base: " + err);
                    });
            });

            // Al enviar el formulario, reconstruir JSON desde los campos
            form.addEventListener("submit", function (e) {
                const inputs = tbody.querySelectorAll("input[data-path]");
                if (!inputs.length) {
                    alert("No hay campos JSON cargados para generar.");
                    e.preventDefault();
                    return;
                }

                const pairs = [];
                inputs.forEach((input) => {
                    pairs.push({ path: input.dataset.path, value: input.value });
                });

                try {
                    const obj = unflattenJson(pairs);
                    hidden.value = JSON.stringify(obj, null, 2);
                } catch (err) {
                    console.error(err);
                    alert("Error reconstruyendo el JSON: " + err);
                    e.preventDefault();
                }
            });

            // Disparar una carga inicial con el primer JSON de la lista (si hay)
            if (select.value) {
                const event = new Event("change");
                select.dispatchEvent(event);
            }
        }

        document.addEventListener("DOMContentLoaded", function () {
            setupJsonEditor("word");
            setupJsonEditor("excel");
            setupJsonCreator();
        });
    </script>
</body>
</html>
